@code_type d .d
@comment_type // %s
@compiler make debug -C ..
@error_format .*/%f\(%l,%s\):%s: %m

@title Parser

@s Introduction

This is an implementation of a literate programming system in D.
The goal is to be able to create books that one can read on a website,
with chapters, subchapters, and sections, and additionally to be able
to compile the code from the book into a working program.

Literate proogramming aims to make the source code of a program
understandable. The program can be structured in any way the
programmer likes, and the code should be explained.

The source code for a literate program will somewhat resemble
CWEB, but differ in many key ways which simplify the source code
and make it easier to read. Literate will use @ signs for commands
and markdown to style the prose. 

@s Directory Structure

A Literate program may be just a single file, but it should also be
possible to make a book out of it, with chapters and possibly multiple
programs in a single book. If the literate command line tool is run on
a single file, it should compile that file, if it is run on a directory,
it should search for the `Summary.lit` file in the directory and create a
book.

What should the directory structure of a Literate book look like?
I try to mimic the [Gitbook](https://github.com/GitbookIO/gitbook) software
here. There will be a `Summary.lit` file which links to each of the
different chapters in the book. An example `Summary.lit` file might look
like this:

    @title Title of the book
    
    [Chapter 1](chapter1/intro.lit)
        [Subchapter 1](chapter1/example1.lit)
        [Subchapter 2](chapter1/example2.lit)
    [Chapter 2](section2/intro.lit)
        [Subchapter 1](chapter2/example1.lit)

Sub chapters are denoted by tabs, and each chapter is linked to the correct
`.lit` file using Markdown link syntax.

@s The Parser

As a first step, I'll make a parser for single chapters only, and leave having
multiple chapters and books for later.

The parser will have 2 main parts to it: the which represent the various structures
in a literate program, and the parse function.

--- parser.d
@{Imports}
@{Classes}
@{Parse functions}
---

I'll quickly list the imports here.

--- Imports
import globals;
import std.stdio;
import util;
import std.string: split, endsWith, startsWith, chomp, replace, strip, stripRight, format;
import std.algorithm: canFind;
import std.regex: matchAll, matchFirst, regex, ctRegex, splitter;
import std.conv;
import std.path: extension;
import std.file;
---

@s

Now we have to define the classes used to represent a literate program. There
are 7 such classes:

--- Classes
@{Line class}
@{Command class}
@{Block class}
@{Section class}
@{Chapter class}
@{Program class}
@{Change class}
---

@s The Program Class

What is a literate program at the highest level? A program has multiple chapters,
it has a title, and it has various commands associated with it (although some of these
commands may be overwritten by chapters or even sections). It also has the file it
originally came from.

--- Program class
class Program {
    public string title;
    public Command[] commands;
    public Chapter[] chapters;
    public string file;
    public string text;

    this() {
        commands = [];
        chapters = [];
    }
}
---

@s The Chapter class

A chapter is very similar to a program. It has a title, commands, sections, and also
an original file. In the case of a single file program (which is what we are focusing
on for the moment) the Program's file and the Chapter's file will be the same. A chapter
also has a minor number and a major number;

--- Chapter class
class Chapter {
    public string title;
    public Command[] commands;
    public Section[] sections;
    public string file;

    public int majorNum;
    public int minorNum;

    this() {
        commands = [];
        sections = [];
    }

    string num() {
        if (minorNum != 0) {
            return to!string(majorNum) ~ "." ~ to!string(minorNum);
        } else {
            return to!string(majorNum);
        }
    }
}
---

@s The Sections class

A section has a title, commands, a number, and a series of blocks, which can either be
blocks of code, or blocks of prose.

--- Section class
class Section {
    public string title;
    public Command[] commands;
    public Block[] blocks;
    public int num;

    this() {
        commands = [];
        blocks = [];
    }
}
---

@s The Block Class

A block is more interesting. It can either be a code, file, or prose block, so use an
enumeration to represents what type it is. It also stores a start line. Code and file
block have names and file blocks have a flag to indicate if they are executable or not.
Finally, it stores an array of lines, and has a function called `text()` which just
returns the string of the text it contains. A block also contains a `codeType` and a
`commentString`.

--- Block class
enum BlockType {
    UNDEFINED,
    CODE,
    FILE,
    PROSE
} 

class Block {
    public Line startLine;
    public string name;
    public BlockType blockType;
    public bool makeExecutable;
    public bool isRootBlock;
    public Line[] lines;

    public string codeType;
    public string commentString;

    public Modifier[] modifiers;

    this() {
        blockType = BlockType.UNDEFINED;
        lines = [];
        modifiers = [];
    }

    string text() {
        string text = "";
        foreach (line; lines) {
            text ~= line.text ~ "\n";
        }
        return text;
    }

    Block dup() {
        Block b = new Block();
        b.startLine = startLine;
        b.name = name;
        b.blockType = blockType;
        b.codeType = codeType;
        b.commentString = commentString;
        b.modifiers = modifiers;

        foreach (Line l; lines) {
            b.lines ~= l.dup();
        }

        return b;
    }
}
---

@s The Command Class

A command is quite simple. It has a name, and any arguments that are passed.

--- Command class
class Command {
    public string name;
    public string args;
    public int lineNum;
    public string filename;
    this() {}
}
---

@s The Line Class

A line is the lowest level. It stores the line number, the file the line is from, and the
text for the line itself.

--- Line class
class Line {
    public string file;
    public int lineNum;
    public string text;

    this(string text, string file, int lineNum) {
        this.text = text;
        this.file = file;
        this.lineNum = lineNum;
    }

    Line dup() {
        return new Line(text, file, lineNum);
    }
}
---

@s The Change Class

The change class helps when parsing a change statement. It stores the file that is being changed,
what the text to search for is and what the text to replace it with is. These two things are arrays
because you can make multiple changes (search and replaces) to one file. In order to
keep track of the current change, an index is also stored.

--- Change class
class Change {
    public string filename;
    public string[] searchText;
    public string[] replaceText;
    public int index;

    this() {
        searchText = [];
        replaceText = [];
        index = 0;
    }
}
---

That's it for the classes. These 7 classes can be used to represent an entire literate program.
Now let's get to the actual parse function to turn a text file into a program.

@s The Parse Function

Here we have two functions: `parseProgram` and `parseChapter`.

--- Parse functions
@{parseProgram function}
@{parseChapter function}
---

@s parseProgram function

This function takes a literate book source and parses each chapter and returns the final program.

Here is an example book:

    @title Title of the book

    [Chapter 1](chapter1/intro.lit)
        [Subchapter 1](chapter1/example1.lit)
        [Subchapter 2](chapter1/example2.lit)
    [Chapter 2](section2/intro.lit)
        [Subchapter 1](chapter2/example1.lit)

--- parseProgram function
Program parseProgram(Program p, string src) {
    string filename = p.file;
    bool hasChapters;

    string[] lines = src.split("\n");
    int lineNum;
    int majorNum;
    int minorNum;
    foreach (line; lines) {
        lineNum++;

        if (line.startsWith("@title")) {
            p.title = strip(line[6..$]);
        } else if (line.startsWith("@book")) {
            continue;
        } else if (auto matches = matchFirst(line, regex(r"\[(?P<chapterName>.*)\]\((?P<filepath>.*)\)"))) {
            if (matches["filepath"] == "") {
                error(filename, lineNum, "No filepath for " ~ matches["chapterName"]);
                continue;
            }
            if (leadingWS(line).length > 0) {
                minorNum++;
            } else {
                majorNum++;
                minorNum = 0;
            }
            Chapter c = new Chapter();
            c.file = matches["filepath"];
            c.title = matches["chapterName"];
            c.majorNum = majorNum;
            c.minorNum = minorNum;

            p.chapters ~= parseChapter(c, readall(File(matches["filepath"])));
            hasChapters = true;
        } else {
            p.text ~= line ~ "\n";
        }
    }

    return p;
}
---

@s parseChapter function

The `parseChapter` function is the more complex one. It parses the source of a chapter.
Before doing any parsing, we resolve the `@include` statements by replacing them with
the contents of the file that was included. Then we loop through each line in the source
and parse it, provided that it is not a comment (starting with `//`);

--- parseChapter function
Chapter parseChapter(Chapter chapter, string src) {
    @{Initialize some variables}

    string[] blocks = [];

    string include(string file) {
        if (file == filename) {
            error(filename, 1, "Recursive include");
            return "";
        }
        if (!exists(file)){
            error(filename, 1, "File " ~ file ~ " does not exist");
            return "";
        }
        return readall(File(file));
    }

    // Handle the @include statements
    /* src = std.regex.replaceAll!(match => include(match[1]))(src, regex(`\n@include (.*)`)); */
    string[] linesStr = src.split("\n");
    Line[] lines;
    foreach (lineNum, line; linesStr) {
        lines ~= new Line(line, filename, cast(int) lineNum+1);
    }

    for (int j = 0; j < lines.length; j++) {
        auto lineObj = lines[j];
        filename = lineObj.file;
        auto lineNum = lineObj.lineNum;
        auto line = lineObj.text;

        if (strip(line).startsWith("//") && !inCodeOrFileBlock) {
            continue;
        }

        @{Parse the line}
    }
    @{Close the last section}

    return chapter;
}
---

@s The Parse Function Setup

For the initial variables, it would be nice to move the value for `chapter.file` into a variable
called `filename`. Additionally, I'm going to need an array of all the possible commands that
are recognized.

--- Initialize some variables
string filename = chapter.file;
string[] commands = ["@code_type", "@comment_type", "@compiler", "@error_format", 
                     "@add_css", "@overwrite_css", "@colorscheme", "@include"];
---

I also need to keep track of the current section that is being parsed, and the current block that
is being parsed, because the parser is going through the file one line at a time. I'll also define
the current change being parsed.

--- Initialize some variables +=
Section curSection;
int sectionNum = 0;
Block curBlock;
Change curChange;
---

Finally, I need flags to keep track of if a @code or @file block has been opened or if it is
currently parsing a code or file block, a search block, or a replace block.

--- Initialize some variables +=
bool codeBlockOpened = false;
bool fileBlockOpened = false;
bool inCodeOrFileBlock = false;
bool inSearchBlock = false;
bool inReplaceBlock = false;
---

@s Parsing the Line

When parsing a line, we are either inside a code block, inside a file block, inside a prose
block, or we are transitioning from one to the other. So we'll have an if statement to
separate the two.

--- Parse the line
if (!codeBlockOpened && !fileBlockOpened && !inCodeOrFileBlock) {
    // This might be a change block
    @{Parse change block}
    @{Parse a command}
    @{Parse a title command}
    @{Parse a code command}
    @{Parse a file command}
    @{Parse a section definition}
    else if (curBlock !is null) {
        if (line.split().length > 1) {
            if (commands.canFind(line.split()[0])) {
                continue;
            }
        }
        @{Add the line to the list of lines}
    }
} else if (codeBlockOpened || fileBlockOpened) {
     @{Parse the beginning of a code or file block}
} else if (startsWith(line, "```")) {
    @{Begin a new prose block}
} else if (curBlock !is null) {
    @{Add the line to the list of lines}
}
---

Parsing commands is fairly simple, so let's look at that first.

To parse a command we first make sure that there is the command name, and any arguments.
Then we check if the command is part of the list of commands we have. If it is, we
create a new command object, fill in the name and arguments, and add it to the chapter object.

We also do something special if it is a `@include` command. For these ones, we take the file
read it, and parse it as a chapter (using the `parseChapter` function). Then we add the
included chapter's sections to the current chapter's sections. In this case, we don't add
the `@include` command to the list of chapter commands.

--- Parse a command
if (line.split().length > 1) {
    if (commands.canFind(line.split()[0])) {
        Command cmd = new Command();
        cmd.name = line.split()[0];
        auto index = cmd.name.length;
        cmd.args = strip(line[index..$]);
        cmd.lineNum = lineNum;
        cmd.filename = filename;
        if (cmd.args == "none") {
            cmd.args = "";
        }

        if (cmd.name == "@include") {
            Line[] includedLines;
            string fileSrc = readall(File(cmd.args));
            foreach (includedLineNum, includedLine; fileSrc.split("\n")) {
                auto includedLineObj = new Line(includedLine, cmd.args, cast(int) includedLineNum + 1);
                includedLines ~= includedLineObj;
            }
            if (includedLines.length > 0) {
                lines = lines[0 .. lineNum] ~ includedLines ~ lines[lineNum .. $];
            }
        }

        if (curSection is null) {
            chapter.commands ~= cmd;
        } else {
            curSection.commands ~= cmd;
        }
    }
}
---

Parsing an `@title` command is even simpler.

--- Parse a title command
if (startsWith(line, "@title")) {
    chapter.title = strip(line[6..$]);
}
---

@s Parsing code and file commands

Parsing the `@code` command is a bit more complicated. The line will always begin with
`@code` and will be followed by the title and optional code modifiers. Any open block
must then be appended to the current section's list of blocks, and the current codeblock
must be reset.

--- Parse a code command
else if (startsWith(line, "@code")) {
    @{Parse code block name and modifiers}
    @{Save the current block}
    @{Create a new block}
    curBlock.blockType = BlockType.CODE;
    @{Add block name to list}
    codeBlockOpened = true;
}
---

--- Parse code block name and modifiers
auto name = strip(line[5..$]);
Modifier[] modifiers;
if (endsWith(name, "+=")) {
    modifiers ~= Modifier.additive;
    name = name.stripRight("+=");
} else if (endsWith(name, ":=")) {
    modifiers ~= Modifier.redef;
    name = name.stripRight(":=");
}
---

Parsing the `@file` command is similar to parsing the `@code` command. The line will
always begin with `@file` and will be followed by the file name and optional file modifiers.
The rest of the steps are similar.

--- Parse a file command
else if (startsWith(line, "@file")) {
    @{Parse file block name and modifiers}
    @{Save the current block}
    @{Create a new block}
    curBlock.blockType = BlockType.FILE;
    @{Add block name to list}
    fileBlockOpened = true;
}
---

--- Parse file block name and modifiers
auto name = strip(line[5..$]);
Modifier[] modifiers;
if (endsWith(name, "+x")) {
    modifiers ~= Modifier.executable;
    name = name.stripRight("+x");
}
---

Saving the current block involves making sure that a section has been defined and then
adding any existing block to that section's block list.

--- Save the current block
if (curSection is null) {
    error(chapter.file, lineNum, "You must define a section with @s before writing a code block");
    continue;
}
if (curBlock !is null) {
    curSection.blocks ~= curBlock;
}
---

Creating a new block is simple. Make sure to strip any leading or trailing whitespace from the
name.

--- Create a new block
curBlock = new Block();
curBlock.startLine = lineObj;
curBlock.name = name.strip(" ");
curBlock.modifiers = modifiers;
foreach (cmd; curSection.commands) {
    if (cmd.name == "@code_type") {
        curBlock.codeType = cmd.args;
    } else if (cmd.name == "@comment_type") {
        curBlock.commentString = cmd.args;
    }
}
---

Check for block redefinition when adding the new block name to the list.

--- Add block name to list
if (blocks.canFind(curBlock.name)) {
    if (!curBlock.modifiers.canFind(Modifier.redef) && !curBlock.modifiers.canFind(Modifier.additive)) {
        error(filename, lineNum, "Redefinition of {" ~ curBlock.name ~ "}, use ':=' to redefine");
    }
} else {
    blocks ~= curBlock.name;
}
---

@s Parsing a Section Definition

When a new section is created (using `@s`), we should add the current section to the list
of sections for the chapter, and then we should create a new section, which becomes the
current section.

--- Parse a section definition
else if (startsWith(line, "@s")) {
    if (curBlock !is null && (curBlock.blockType == BlockType.PROSE)) {
        if (strip(curBlock.text()) != "") {
            curSection.blocks ~= curBlock;
        }
    } else if (curBlock !is null && (curBlock.blockType != BlockType.PROSE)) {
        error(curBlock.startLine.file, curBlock.startLine.lineNum, "Unclosed block {" ~ curBlock.name ~ "}");
    }
    // Make sure the section exists
    if (curSection !is null) {
        chapter.sections ~= curSection;
    }
    curSection = new Section();
    curSection.title = strip(line[2..$]);
    curSection.commands = chapter.commands ~ curSection.commands;
    curSection.num = ++sectionNum;

    curBlock = new Block();
    curBlock.blockType = BlockType.PROSE;
}
---

@s Parse the beginning of a code or file block

The previous line was a `@code` or `@file` statement so this line must start with "```" and
may optionally include the language.

--- Parse the beginning of a code or file block
if (startsWith(line, "```")) {
    codeBlockOpened = false;
    fileBlockOpened = false;
    inCodeOrFileBlock = true;
} else {
    error(chapter.file, lineNum, "The line following a @code or @file statement must be a code block");
    continue;
}

---

@s Parse the End of a Codeblock

Codeblocks end with just a "```". When a codeblock ends, we do the same as when it begins,
except the new block we create is a block of prose as opposed to code.

--- Begin a new prose block
if (curBlock !is null) {
    curSection.blocks ~= curBlock;
}
curBlock = new Block();
curBlock.startLine = lineObj;
curBlock.blockType = BlockType.PROSE;
inCodeOrFileBlock = false;
---

@s Add the current line

Finally, if the current line is nothing interesting, we just add it to the current block's
list of lines.

--- Add the line to the list of lines
curBlock.lines ~= new Line(line, filename, lineNum);
---

Now we're done parsing the line.

@s Closing the last section

When the end of the file is reached, the last section has not been closed and added to the
chapter yet, so we should do that. Additionally, if the last block is a prose block, it should
be closed and added to the section first. If the last block is a code block, it should have been
closed with `---`. If it wasn't we'll throw an error.

--- Close the last section
if (curBlock !is null) {
    if (curBlock.blockType == BlockType.PROSE) {
        curSection.blocks ~= curBlock;
    } else {
        error(filename, cast (int)(lines.length - 1), "{%s} is never closed".format(curBlock.name));
    }
}
if (curSection !is null) {
    chapter.sections ~= curSection;
}
---

@s Parsing the change block

Parsing a change block is somewhat complex. Change blocks look like this:

    @change file.lit
    
    Some comments here...
    
    @replace
    replace this text
    @with
    with this text
    @end
    
    More comments ...
    
    @replace
    ...
    @with
    ...
    @end
    
    ...
    
    @change_end

You can make multiple changes on one file. We've got two nice flags for keeping track of
which kind of block we are in: replaceText or searchText.

--- Parse change block
// Start a change block
if (startsWith(line, "@change") && !startsWith(line, "@change_end")) {
    curChange = new Change();
    curChange.filename = strip(line[7..$]);
    continue;
} else if (startsWith(line, "@replace")) {
    // Begin the search block
    curChange.searchText ~= "";
    curChange.replaceText ~= "";
    inReplaceBlock = false;
    inSearchBlock = true;
    continue;
} else if (startsWith(line, "@with")) {
    // Begin the replace block and end the search block
    inReplaceBlock = true;
    inSearchBlock = false;
    continue;
} else if (startsWith(line, "@end")) {
    // End the replace block
    inReplaceBlock = false;
    inSearchBlock = false;
    // Increment the number of changes
    curChange.index++;
    continue;
} else if (startsWith(line, "@change_end")) {
    // Apply all the changes
    string text = readall(File(curChange.filename));
    foreach (i; 0 .. curChange.index) {
        text = text.replace(curChange.searchText[i], curChange.replaceText[i]);
    }
    Chapter c = new Chapter();
    c.file = curChange.filename;
    // We can ignore these, but they need to be initialized
    c.title = "";
    c.majorNum = -1;
    c.minorNum = -1;
    Chapter includedChapter = parseChapter(c, text);
    // Overwrite the current file's title and add to the commands and sections
    chapter.sections ~= includedChapter.sections;
    chapter.commands ~= includedChapter.commands;
    chapter.title = includedChapter.title;
    continue;
}

// Just add the line to the search or replace text depending
else if (inSearchBlock) {
    curChange.searchText[curChange.index] ~= line ~ "\n";
    continue;
} else if (inReplaceBlock) {
    curChange.replaceText[curChange.index] ~= line ~ "\n";
    continue;
}
---
